https://pixelbits.16-b.it/GBEDG/ppu/

翻訳中

# PPUの仕組み
## はじめに
PPU（Picture Processing Unitの略）とは、ゲームボーイで画面に表示されるすべての情報を処理している部分です。CPUの次に重要なパーツですが、複雑さではCPUを圧倒的に上回ります。PPUはもっと厄介で、明確なドキュメントがないため、ここでは簡単で素早く理解できるような要約を提供したいと思います。

## 警告の言葉

このドキュメントは100％正確ではありません。様々な情報源から得た情報と、私がエミュレータを開発している間に個人的に経験したことを組み合わせたものです。もし何かおかしな点があれば、Discord (Optix™#1337) で私個人と連絡を取るか、PRを作成してください。

また、このドキュメントの現在のバージョンはDMGエミュレーションにのみ焦点を当てており、CGBやSGBの機能は考慮されていません。

## 基本情報
### 画面について

初代DMGゲームボーイの画面は160x144ピクセルのLCDで、最大4色のグレーを表示することができます。DMGでは緑色で表示されますが、多くのエミュレータではカスタムカラーパレットに対応しており、ユーザーが手動で表示する色を設定することができます。
タイルの概念

画面の解像度は160×144ピクセルだが、ピクセルに直接「書き込む」ことはできない。ゲームボーイでは、8×8ピクセルのタイルしか表示できません。これは多かれ少なかれ「8×8ピクセルの固定テクスチャ」であり、画面上に一定のグリッドで配置することができる。これにはいくつかの例外がありますが、それは後で説明します。



![8x8](https://github.com/asaioe99/Gameboy/blob/main/img/8x8_tile.png)

### 画素データ

DMGの初代Gameboyは4色のパレットにしか対応していないため、1画素の色データを格納するのに2ビットが必要となる。そのため、Gameboyでは「2BPP」（2 bit per pixel）と呼ばれる方式で画像データを記録している。

Gameboyの2BPPフォーマットでは、2バイトで8画素の列を構成する。1バイト目の各ビットと2バイト目の同じ位置のビットを組み合わせて色番号を計算します。ここでは、0xA5 0xC3 を例として説明します。

![gb_2bpp](https://github.com/asaioe99/Gameboy/blob/main/img/gb_2bpp.png)

メモリ上のタイルは、上記の方法で符号化された16バイトで格納される。最初の2バイトが8画素の1行目、次の2バイトが2行目、といった具合に表現される。

## ディスプレイのレイヤー
Gameboyのディスプレイは、「背景」「ウィンドウ」「スプライト」という3つのレイヤーを使ってグラフィックを表示します。

### 背景
背景は、32×32ピクセル（256×256ピクセル）のタイルで、この中にタイルを配置することができます。ただし、GameBoyでは、20×18ピクセル（160×144ピクセル）分の背景しか表示できません。この部分を「ビューポート」と呼びます。どの部分を表示するかは、SCXとSCYレジスタ（後述）を使って決めることができ、プログラムで設定することができる。これらのレジスタの値は、ビューポートが背景の左と上の境界線からそれぞれ何ピクセルオフセットされているかを決定する。ビューポートが背景のボーダーを超えると、それぞれ左/上に折り返される。

![grid_bg](https://github.com/asaioe99/Gameboy/blob/main/img/grid_bg.png)

### ウィンドウ

ウィンドウは背景と同じで、32x32のタイルグリッドで、タイルを配置することができます。しかし、これは背景の上にある一種の「オーバーレイ」と見ることができ、その位置はWXとWYレジスタを使って決定することができます（これについても後ほど説明します）。

![grid_win](https://github.com/asaioe99/Gameboy/blob/main/img/grid_win.png)

#### WXレジスタとWYレジスタ

WYレジスタは、2つのレジスタのうちより単純なものです。メモリアドレス$FF4Aを使用して、プログラムは、ウィンドウの最上部の境界を配置するY位置を設定することができます（0は最上部を意味します）。

メモリ・アドレス$FF4BにあるWXレジスタには、少し奇妙な点があります。ウィンドウを画面の左端に配置するには、レジスタに値7を書き込まなければなりません。7より小さい値は、奇妙なエッジケースを発生させますが、ここではまだ文書化されていません。しかし、7以下のWX値を使用するゲームでは、ほとんど無視することができます。

事実上、ウィンドウが表示されるべき水平位置は、WX - 7で計算できます。たとえば、WX 値が 6 の場合（前述のエッジケースを無視）、左端の列のピクセルが画面外に置かれ、2 列目でウィンドウのレンダリングが開始されます（この例を参照してください）。

![grid_win_wx06](https://github.com/asaioe99/Gameboy/blob/main/img/grid_win_wx06.png)

(注：上記のグラフィックはノンスケールです)

### スプライト

スプライトは、背景やウィンドウのグリッドに制限されない8x8（または特定のオプションを設定した場合は8x16）ピクセルのタイルのようなものです。スプライトデータはメモリのOAMセクションに格納され、最大40個のスプライトを格納することができます。

![grid_sprites](https://github.com/asaioe99/Gameboy/blob/main/img/grid_sprites.png)

## タイルデータ

2BPP形式（上記説明）で符号化されたグラフィックデータは、アドレス$8000-$97FFのVRAMに格納され、通常、いわゆる「タイル番号」で参照される。各タイルは16バイトのメモリを占有するため、「タイル番号」は基本的にVRAMのこのセクション内の16バイトブロックのインデックスに過ぎない。ただし、PPUが採用しているアドレッシング方式は2種類ある。

8000方式は、8000ドルをベースポインタとして、これに（TILE_NUMBER * 16）を加算するもので、TILE_NUMBERは符号なし8ビット整数である。したがって、タイル番号0はアドレス$8000を指し、1は$8010を指し、2は$8020を指し、以下同様である。

8800方式では、$9000をベースポインタとし、これに(SIGNED_TILE_NUMBER * 16)を加える。ここで、SIGNED_TILE_NUMBERは符号付き8ビット整数である。したがって、タイル番号0はアドレス$9000を指し、1は$9010を指し、2は$9020を指し、以下同様である。しかし、0xFFは$8FF0を、0xFEは$8FE0を参照するようになります。

これらのどのアドレス指定方法を使うかは、LCDCレジスタのビット4に依存するが、これについても後ほど説明する。

## 背景マップ

背景/ウィンドウグリッドに表示されるべきタイルを設定するために、背景マップが使用されます。VRAMセクション$9800-$9BFFと$9C00-$9FFFはそれぞれ、この背景マップを1つずつ含んでいます。

背景マップは、32x32バイトのタイル番号で構成され、行ごとに整理されている。つまり、背景マップの最初のバイトは、一番左上のタイルのタイル番号である。その次のバイトは、その右隣のタイルのタイル番号というように。33バイト目は、2番目のタイル行の一番左のタイルのタイル番号を表すことになる。

## OAMメモリー

OAM（Object Attribute Memoryの略）は、$FE00〜$FE9Fの範囲で、スプライト（オブジェクト）を画面上に表示するためのデータを格納するメモリである。1つのスプライトは4バイトで、合計40個のスプライトを表示することができます。各エントリーは以下のような構成になっています。

バイト0 - Y-ポジション。バイト0 - Y-ポジション：各エントリの最初のバイトは、画面上のスプライトの垂直位置を表します。ただし、スプライトを上部からスムーズにフレーム内に移動できるようにするため、この値から16を引いて実際のY-Positionを決定しています。つまり、Y-Positionが16の場合、スプライトは画面の上部の境界線に配置されます。

バイト1 - X-Position。2バイト目は、画面上のスプライトの水平位置を表します。Yポジションと同様に、この値から8を引くことで、スプライトをスムーズにフレーム内に移動させることができます。つまり、Xポジションが8の場合はスプライトが画面の左端に位置し、0の場合はスプライトが完全に隠れることになります。

バイト2 - タイル番号。各OAMエントリの3バイト目は、スプライトのグラフィックスデータを取得するために使用されるタイル番号を表します。スプライトは常に "8000アドレス方式 "を使用するため、この値は常に符号なし8ビット整数として解釈されることに注意してください。

バイト3 - スプライトフラグ。各エントリの最後のバイトには、スプライトに特定の効果やオプションを適用するためのビットフラグが含まれています。

```
Bit 7    OBJ-to-BG Priority
          0 = Sprite is always rendered above background
          1 = Background colors 1-3 overlay sprite, sprite is still rendered above color 0
Bit 6    Y-Flip
          If set to 1 the sprite is flipped vertically, otherwise rendered as normal
Bit 5    X-Flip
          If set to 1 the sprite is flipped horizontally, otherwise rendered as normal
Bit 4    Palette Number
          If set to 0, the OBP0 register is used as the palette, otherwise OBP1
Bit 3-0  CGB-Only flags
```

## スキャンラインの概念

PPUは、液晶ディスプレイ上の全画素を直接設定するわけにはいかないので、フレームのレンダリングには「スキャンライン」という概念を用いる。スキャンラインとは、簡単に言えば画面上に並んだ画素のことだ。PPUはスキャンラインに沿って左から右へと進み、1つずつ画素を配置していき、それが終わると次のスキャンラインに進みます。PPUはピクセルベースで動作し、タイルベースではないことに注意してください。

![scanlines_basic](https://github.com/asaioe99/Gameboy/blob/main/img/scanlines_basic.png)

PPUが現在処理しているスキャンラインの番号は、いわゆるLYレジスタに格納されているため、「現在のスキャンライン番号」の代わりに「LY」という言葉が使われることが多い。

## PPUのモードの概念

スキャンライン中、PPUは複数の異なるモードに入り、それぞれが特定の機能を持つ。これらのモードは全部で4つあります。
### OAMスキャン(モード2)

このモードは、各スキャンライン（V-Blankを除く）の開始時に、実際にピクセルが画面に描画される前に入る。このモードでは、PPUは現在のスキャンラインに描画されるべきスプライトをOAMメモリに検索し、バッファに格納する。これは、PPUが2T-Cycleごとに新しいOAMエントリをチェックすることを意味する。

スプライトは、次の条件がすべて当てはまる場合にのみ、バッファに追加されます。

```
    スプライトのX位置は0より大きくなければなりません。
    LY + 16はスプライトのY位置以上でなければなりません。
    LY + 16がスプライトY位置 + スプライト高さ（Normalモードでは8、Tall-Spriteモードでは16）より小さい必要があります。
    OAM Bufferに格納されているスプライトの量が10個未満であること。
```

### 描画（モード3）

描画モードは、PPUがLCDに画素を転送するモードである。このモードの持続時間は、背景のスクロール、スキャンライン上のスプライトの量、ウィンドウをレンダリングすべきかどうかなど、複数の変数によって変化する。これらのタイミングの違いの詳細については、すべて後ほど説明します。
### Hブランク（モード0）

このモードは、描画モード終了後のスキャンラインの残りを占め、スキャンラインの期間を合計456T-Cycleに多かれ少なかれ「パディング」する。このモードでは、PPUは実質的に一時停止する。
### V-Blank（モード1）

V-Blankモードは、PPUがLCDに画素を描画しない点ではH-Blankモードと同じである。ただし、スキャンラインごとの終了ではなく、フレームごとの終了でより長い時間行われる。

Gameboyの垂直解像度は144ピクセルなので、PPUが扱うスキャンラインの量も144スキャンラインと等しくなると予想される。しかし、そうではない。実際には154本のスキャンラインがあり、そのうち最後の10本は「疑似スキャンライン」で、その間はPPUがV-Blank状態であるため、画素が描画されない。V-Blankスキャンラインは、他のスキャンラインと同じ456T-Cyclesの時間がかかる。
### タイミング図

上記の各モードのタイミングを視覚的に説明したのが、以下の図（ゲームボーイパンドックスのオリジナルを簡略化したもの）である。

![ppu_mode_timing_basic](https://github.com/asaioe99/Gameboy/blob/main/img/ppu_mode_timing_basic.png)

## ピクセルFIFO

Gameboyでは、フレーム全体、あるいはスキャンライン全体を同時にレンダリングすることはない。その代わりに、個々のピクセルが1つずつLCDにプッシュされる。そのために、「ピクセルFIFO」と呼ばれるものが使われている。これは2つの「シフトレジスタ」を組み合わせたもので、それぞれが最大8画素のデータを保持することができる。FIFOに格納される各ピクセルは、以下のプロパティを追跡する必要があります。

```
    色：色番号（パレットを無視し、この値はタイルデータからの色値である）。
    パレット。DMGの場合はOBP0 / OBP1、CGBの場合は0から7までの値
    スプライトの優先順位。CGBのスプライトにのみ関係します。
    背景の優先順位。スプライトの属性バイトのビット7（OBJ-to-BG Priority）の値が保持されます。
```

この8ピクセルのシフトレジスタのうち、1つは背景/ウィンドウデータのピクセルをロードするため、「バックグラウンドFIFO」と呼ばれます。もう1つはスプライトFIFOで、スプライトのピクセルをバッファリングする役割を担っています。この2つのレジスタからのピクセルは、LCDにシフトアウトされる過程でマージされるが、このプロセスについては後で詳しく説明する。

### OAMスキャン

各スキャンラインの開始時に、PPUは現在のスキャンラインでレンダリングする必要があるスプライトのためにOAMをスキャンする。この動作の詳細については、「OAMスキャン（モード2）」の項で説明します。レンダリングすべきスプライトが格納されるバッファは、「スプライトバッファ」と呼ばれる。

### 背景画素のフェッチ

FIFOレジスタにデータをロードするコンポーネントは、Pixel Fetcherです。このフェッチャーは、PPU Mode 3の間、常にアクティブで、FIFOに新しいピクセルを供給し続け、シフトアウトさせる。ピクセルフェッチプロセスは4つのステップに分かれており、それぞれ2Tサイクルの時間をかけて完了する。

```


    1) タイル番号の取得：最初のステップで、フェッチャーは使用すべきタイルのタイル番号を取得し保存する。どのタイルマップを使用するかは、PPUが現在BackgroundピクセルとWindowピクセルのどちらをレンダリングしているか、またLCDCレジスタのビット3と5によって決まる。さらに、タイル番号が読み出されるアドレスは、最後のステップが完了するたびに増分されるフェッチャ内部X-Position-Counterによってオフセットされる。また、フェッチャーがウィンドウピクセルをフェッチしていない場合は、SCX / 8の値も追加されます。SCXによるラップアラウンドを動作させるために、このオフセットは0x1fとANDされる。背景ピクセルがフェッチされている場合は、32 * ((LY + SCY) & 0xFF) / 8 のオフセットも追加され、ウィンドウピクセルがフェッチされている場合は、32 * (WINDOW_LINE_COUNTER / 8) でこのオフセットが決定される。ウィンドウラインカウンターはフェッチャー内部変数で、スキャンライン上にウィンドウピクセルがあるたびにインクリメントされ、VBlankモードに入るとリセットされます。

    注：X-POS+SCX と LY+SCY オフセットの和は、アドレスがタイルマップメモリ領域内に留まることを保証するために 0x3ff と AND される。

    2) タイルデータ(Low)を取得する。前のステップのタイル番号を使用して、フェッチャーはタイルデータの最初のバイトをフェッチし（2 * ((LY + SCY) mod 8)のオフセットを持つ）、それを格納します。タイルデータが読み込まれるアドレスは、LCDCレジスタのビット4によって決まります。

    注：ウィンドウピクセルをフェッチしている間、2 * ((LY + SCY) mod 8)のオフセットは、2 * (WINDOW_LINE_COUNTER mod 8)に置き換わります。

    3) タイルデータのフェッチ(High): このステップは前のステップと同じであるが、前に読まれたアドレスの次のバイト（タイルデータの2バイト目を含む）が読まれ、保存される。

    注：バックグラウンド・フェッチャーがスキャンライン上で初めてこのステップを完了すると、ステータスは完全にリセットされ、動作はステップ1から再開されます。ここまでの3つのステップが合計で6Tサイクルを占め、同じステップが再び繰り返されて同じ時間がかかるため、バックグラウンドFIFOがピクセルデータで最初に満たされるまで12Tサイクルの遅れが生じます。

    4) FIFOへのプッシュ。このステップでは、以前にフェッチされたピクセルデータが実際のピクセルにデコードされ（前述のすべての属性を含む）、フェッチャーが現在バックグラウンド/ウィンドウまたはスプライトピクセルのいずれをフェッチしているかに応じて、対応するFIFOにロードされます。

    注意: 背景ピクセルをフェッチしている間、このステップは背景 FIFO が完全に空の場合にのみ実行されます。空でない場合、このステップは成功するまで毎サイクル繰り返されます。ここまでのステップは通常6Tサイクルしかかからず、PPUは8Tサイクルで全8ピクセルをシフトアウトするので、このステップは通常成功するまでに2回再起動する必要がある。

```

