https://pixelbits.16-b.it/GBEDG/ppu/

翻訳中

# PPUの仕組み
## はじめに
PPU（Picture Processing Unitの略）とは、ゲームボーイで画面に表示されるすべての情報を処理している部分です。CPUの次に重要なパーツですが、複雑さではCPUを圧倒的に上回ります。PPUはもっと厄介で、明確なドキュメントがないため、ここでは簡単で素早く理解できるような要約を提供したいと思います。

## 警告の言葉

このドキュメントは100％正確ではありません。様々な情報源から得た情報と、私がエミュレータを開発している間に個人的に経験したことを組み合わせたものです。もし何かおかしな点があれば、Discord (Optix™#1337) で私個人と連絡を取るか、PRを作成してください。

また、このドキュメントの現在のバージョンはDMGエミュレーションにのみ焦点を当てており、CGBやSGBの機能は考慮されていません。

## 基本情報
### 画面について

初代DMGゲームボーイの画面は160x144ピクセルのLCDで、最大4色のグレーを表示することができます。DMGでは緑色で表示されますが、多くのエミュレータではカスタムカラーパレットに対応しており、ユーザーが手動で表示する色を設定することができます。

### タイルの概念

画面の解像度は160×144ピクセルだが、ピクセルに直接「書き込む」ことはできない。ゲームボーイでは、8×8ピクセルのタイルしか表示できません。これは多かれ少なかれ「8×8ピクセルの固定テクスチャ」であり、画面上に一定のグリッドで配置することができる。これにはいくつかの例外がありますが、それは後で説明します。



![8x8](https://github.com/asaioe99/Gameboy/blob/main/img/8x8_tile.png)

### 画素データ

DMGの初代Gameboyは4色のパレットにしか対応していないため、1画素の色データを格納するのに2ビットが必要となる。そのため、Gameboyでは「2BPP」（2 bit per pixel）と呼ばれる方式で画像データを記録している。

Gameboyの2BPPフォーマットでは、2バイトで8画素の列を構成する。1バイト目の各ビットと2バイト目の同じ位置のビットを組み合わせて色番号を計算します。ここでは、0xA5 0xC3 を例として説明します。

![gb_2bpp](https://github.com/asaioe99/Gameboy/blob/main/img/gb_2bpp.png)

メモリ上のタイルは、上記の方法で符号化された16バイトで格納される。最初の2バイトが8画素の1行目、次の2バイトが2行目、といった具合に表現される。

## ディスプレイのレイヤー
Gameboyのディスプレイは、「背景」「ウィンドウ」「スプライト」という3つのレイヤーを使ってグラフィックを表示します。

### 背景
背景は、32×32ピクセル（256×256ピクセル）のタイルで、この中にタイルを配置することができます。ただし、GameBoyでは、20×18ピクセル（160×144ピクセル）分の背景しか表示できません。この部分を「ビューポート」と呼びます。どの部分を表示するかは、SCXとSCYレジスタ（後述）を使って決めることができ、プログラムで設定することができる。これらのレジスタの値は、ビューポートが背景の左と上の境界線からそれぞれ何ピクセルオフセットされているかを決定する。ビューポートが背景のボーダーを超えると、それぞれ左/上に折り返される。

![grid_bg](https://github.com/asaioe99/Gameboy/blob/main/img/grid_bg.png)

### ウィンドウ

ウィンドウは背景と同じで、32x32のタイルグリッドで、タイルを配置することができます。しかし、これは背景の上にある一種の「オーバーレイ」と見ることができ、その位置はWXとWYレジスタを使って決定することができます（これについても後ほど説明します）。

![grid_win](https://github.com/asaioe99/Gameboy/blob/main/img/grid_win.png)

#### WXレジスタとWYレジスタ

WYレジスタは、2つのレジスタのうちより単純なものです。メモリアドレス$FF4Aを使用して、プログラムは、ウィンドウの最上部の境界を配置するY位置を設定することができます（0は最上部を意味します）。

メモリ・アドレス$FF4BにあるWXレジスタには、少し奇妙な点があります。ウィンドウを画面の左端に配置するには、レジスタに値7を書き込まなければなりません。7より小さい値は、奇妙なエッジケースを発生させますが、ここではまだ文書化されていません。しかし、7以下のWX値を使用するゲームでは、ほとんど無視することができます。

事実上、ウィンドウが表示されるべき水平位置は、WX - 7で計算できます。たとえば、WX 値が 6 の場合（前述のエッジケースを無視）、左端の列のピクセルが画面外に置かれ、2 列目でウィンドウのレンダリングが開始されます（この例を参照してください）。

![grid_win_wx06](https://github.com/asaioe99/Gameboy/blob/main/img/grid_win_wx06.png)

(注：上記のグラフィックはノンスケールです)

### スプライト

スプライトは、背景やウィンドウのグリッドに制限されない8x8（または特定のオプションを設定した場合は8x16）ピクセルのタイルのようなものです。スプライトデータはメモリのOAMセクションに格納され、最大40個のスプライトを格納することができます。

![grid_sprites](https://github.com/asaioe99/Gameboy/blob/main/img/grid_sprites.png)

## タイルデータ

2BPP形式（上記説明）で符号化されたグラフィックデータは、アドレス$8000-$97FFのVRAMに格納され、通常、いわゆる「タイル番号」で参照される。各タイルは16バイトのメモリを占有するため、「タイル番号」は基本的にVRAMのこのセクション内の16バイトブロックのインデックスに過ぎない。ただし、PPUが採用しているアドレッシング方式は2種類ある。

8000方式は、8000ドルをベースポインタとして、これに（TILE_NUMBER * 16）を加算するもので、TILE_NUMBERは符号なし8ビット整数である。したがって、タイル番号0はアドレス$8000を指し、1は$8010を指し、2は$8020を指し、以下同様である。

8800方式では、$9000をベースポインタとし、これに(SIGNED_TILE_NUMBER * 16)を加える。ここで、SIGNED_TILE_NUMBERは符号付き8ビット整数である。したがって、タイル番号0はアドレス$9000を指し、1は$9010を指し、2は$9020を指し、以下同様である。しかし、0xFFは$8FF0を、0xFEは$8FE0を参照するようになります。

これらのどのアドレス指定方法を使うかは、LCDCレジスタのビット4に依存するが、これについても後ほど説明する。

## 背景マップ

背景/ウィンドウグリッドに表示されるべきタイルを設定するために、背景マップが使用されます。VRAMセクション$9800-$9BFFと$9C00-$9FFFはそれぞれ、この背景マップを1つずつ含んでいます。

背景マップは、32x32バイトのタイル番号で構成され、行ごとに整理されている。つまり、背景マップの最初のバイトは、一番左上のタイルのタイル番号である。その次のバイトは、その右隣のタイルのタイル番号というように。33バイト目は、2番目のタイル行の一番左のタイルのタイル番号を表すことになる。

## OAMメモリー

OAM（Object Attribute Memoryの略）は、$FE00〜$FE9Fの範囲で、スプライト（オブジェクト）を画面上に表示するためのデータを格納するメモリである。1つのスプライトは4バイトで、合計40個のスプライトを表示することができます。各エントリーは以下のような構成になっています。

バイト0 - Y-ポジション。バイト0 - Y-ポジション：各エントリの最初のバイトは、画面上のスプライトの垂直位置を表します。ただし、スプライトを上部からスムーズにフレーム内に移動できるようにするため、この値から16を引いて実際のY-Positionを決定しています。つまり、Y-Positionが16の場合、スプライトは画面の上部の境界線に配置されます。

バイト1 - X-Position。2バイト目は、画面上のスプライトの水平位置を表します。Yポジションと同様に、この値から8を引くことで、スプライトをスムーズにフレーム内に移動させることができます。つまり、Xポジションが8の場合はスプライトが画面の左端に位置し、0の場合はスプライトが完全に隠れることになります。

バイト2 - タイル番号。各OAMエントリの3バイト目は、スプライトのグラフィックスデータを取得するために使用されるタイル番号を表します。スプライトは常に "8000アドレス方式 "を使用するため、この値は常に符号なし8ビット整数として解釈されることに注意してください。

バイト3 - スプライトフラグ。各エントリの最後のバイトには、スプライトに特定の効果やオプションを適用するためのビットフラグが含まれています。

```
Bit 7    OBJ-to-BG Priority
          0 = Sprite is always rendered above background
          1 = Background colors 1-3 overlay sprite, sprite is still rendered above color 0
Bit 6    Y-Flip
          If set to 1 the sprite is flipped vertically, otherwise rendered as normal
Bit 5    X-Flip
          If set to 1 the sprite is flipped horizontally, otherwise rendered as normal
Bit 4    Palette Number
          If set to 0, the OBP0 register is used as the palette, otherwise OBP1
Bit 3-0  CGB-Only flags
```

## スキャンラインの概念

PPUは、液晶ディスプレイ上の全画素を直接設定するわけにはいかないので、フレームのレンダリングには「スキャンライン」という概念を用いる。スキャンラインとは、簡単に言えば画面上に並んだ画素のことだ。PPUはスキャンラインに沿って左から右へと進み、1つずつ画素を配置していき、それが終わると次のスキャンラインに進みます。PPUはピクセルベースで動作し、タイルベースではないことに注意してください。

![scanlines_basic](https://github.com/asaioe99/Gameboy/blob/main/img/scanlines_basic.png)

PPUが現在処理しているスキャンラインの番号は、いわゆるLYレジスタに格納されているため、「現在のスキャンライン番号」の代わりに「LY」という言葉が使われることが多い。

## PPUのモードの概念

スキャンライン中、PPUは複数の異なるモードに入り、それぞれが特定の機能を持つ。これらのモードは全部で4つあります。
### OAMスキャン(モード2)

このモードは、各スキャンライン（V-Blankを除く）の開始時に、実際にピクセルが画面に描画される前に入る。このモードでは、PPUは現在のスキャンラインに描画されるべきスプライトをOAMメモリに検索し、バッファに格納する。これは、PPUが2T-Cycleごとに新しいOAMエントリをチェックすることを意味する。

スプライトは、次の条件がすべて当てはまる場合にのみ、バッファに追加されます。

```
    スプライトのX位置は0より大きくなければなりません。
    LY + 16はスプライトのY位置以上でなければなりません。
    LY + 16がスプライトY位置 + スプライト高さ（Normalモードでは8、Tall-Spriteモードでは16）より小さい必要があります。
    OAM Bufferに格納されているスプライトの量が10個未満であること。
```

### 描画（モード3）

描画モードは、PPUがLCDに画素を転送するモードである。このモードの持続時間は、背景のスクロール、スキャンライン上のスプライトの量、ウィンドウをレンダリングすべきかどうかなど、複数の変数によって変化する。これらのタイミングの違いの詳細については、すべて後ほど説明します。
### Hブランク（モード0）

このモードは、描画モード終了後のスキャンラインの残りを占め、スキャンラインの期間を合計456T-Cycleに多かれ少なかれ「パディング」する。このモードでは、PPUは実質的に一時停止する。
### V-Blank（モード1）

V-Blankモードは、PPUがLCDに画素を描画しない点ではH-Blankモードと同じである。ただし、スキャンラインごとの終了ではなく、フレームごとの終了でより長い時間行われる。

Gameboyの垂直解像度は144ピクセルなので、PPUが扱うスキャンラインの量も144スキャンラインと等しくなると予想される。しかし、そうではない。実際には154本のスキャンラインがあり、そのうち最後の10本は「疑似スキャンライン」で、その間はPPUがV-Blank状態であるため、画素が描画されない。V-Blankスキャンラインは、他のスキャンラインと同じ456T-Cyclesの時間がかかる。
### タイミング図

上記の各モードのタイミングを視覚的に説明したのが、以下の図（ゲームボーイパンドックスのオリジナルを簡略化したもの）である。

![ppu_mode_timing_basic](https://github.com/asaioe99/Gameboy/blob/main/img/ppu_mode_timing_basic.png)

## ピクセルFIFO

Gameboyでは、フレーム全体、あるいはスキャンライン全体を同時にレンダリングすることはない。その代わりに、個々のピクセルが1つずつLCDにプッシュされる。そのために、「ピクセルFIFO」と呼ばれるものが使われている。これは2つの「シフトレジスタ」を組み合わせたもので、それぞれが最大8画素のデータを保持することができる。FIFOに格納される各ピクセルは、以下のプロパティを追跡する必要があります。

```
    色：色番号（パレットを無視し、この値はタイルデータからの色値である）。
    パレット。DMGの場合はOBP0 / OBP1、CGBの場合は0から7までの値
    スプライトの優先順位。CGBのスプライトにのみ関係します。
    背景の優先順位。スプライトの属性バイトのビット7（OBJ-to-BG Priority）の値が保持されます。
```

この8ピクセルのシフトレジスタのうち、1つは背景/ウィンドウデータのピクセルをロードするため、「バックグラウンドFIFO」と呼ばれます。もう1つはスプライトFIFOで、スプライトのピクセルをバッファリングする役割を担っています。この2つのレジスタからのピクセルは、LCDにシフトアウトされる過程でマージされるが、このプロセスについては後で詳しく説明する。

### OAMスキャン

各スキャンラインの開始時に、PPUは現在のスキャンラインでレンダリングする必要があるスプライトのためにOAMをスキャンする。この動作の詳細については、「OAMスキャン（モード2）」の項で説明します。レンダリングすべきスプライトが格納されるバッファは、「スプライトバッファ」と呼ばれる。

### 背景画素のフェッチ

FIFOレジスタにデータをロードするコンポーネントは、Pixel Fetcherです。このフェッチャーは、PPU Mode 3の間、常にアクティブで、FIFOに新しいピクセルを供給し続け、シフトアウトさせる。ピクセルフェッチプロセスは4つのステップに分かれており、それぞれ2Tサイクルの時間をかけて完了する。


1. タイル番号の取得：最初のステップで、フェッチャーは使用すべきタイルのタイル番号を取得し保存する。どのタイルマップを使用するかは、PPUが現在BackgroundピクセルとWindowピクセルのどちらをレンダリングしているか、またLCDCレジスタのビット3と5によって決まる。さらに、タイル番号が読み出されるアドレスは、最後のステップが完了するたびに増分されるフェッチャ内部X-Position-Counterによってオフセットされる。また、フェッチャーがウィンドウピクセルをフェッチしていない場合は、SCX / 8の値も追加されます。SCXによるラップアラウンドを動作させるために、このオフセットは0x1fとANDされる。背景ピクセルがフェッチされている場合は、32 * ((LY + SCY) & 0xFF) / 8 のオフセットも追加され、ウィンドウピクセルがフェッチされている場合は、32 * (WINDOW_LINE_COUNTER / 8) でこのオフセットが決定される。ウィンドウラインカウンターはフェッチャー内部変数で、スキャンライン上にウィンドウピクセルがあるたびにインクリメントされ、VBlankモードに入るとリセットされます。

注：X-POS+SCX と LY+SCY オフセットの和は、アドレスがタイルマップメモリ領域内に留まることを保証するために 0x3ff と AND される。

2. タイルデータ(Low)を取得する。前のステップのタイル番号を使用して、フェッチャーはタイルデータの最初のバイトをフェッチし（2 * ((LY + SCY) mod 8)のオフセットを持つ）、それを格納します。タイルデータが読み込まれるアドレスは、LCDCレジスタのビット4によって決まります。

注：ウィンドウピクセルをフェッチしている間、2 * ((LY + SCY) mod 8)のオフセットは、2 * (WINDOW_LINE_COUNTER mod 8)に置き換わります。

3. タイルデータのフェッチ(High): このステップは前のステップと同じであるが、前に読まれたアドレスの次のバイト（タイルデータの2バイト目を含む）が読まれ、保存される。

注：バックグラウンド・フェッチャーがスキャンライン上で初めてこのステップを完了すると、ステータスは完全にリセットされ、動作はステップ1から再開されます。ここまでの3つのステップが合計で6Tサイクルを占め、同じステップが再び繰り返されて同じ時間がかかるため、バックグラウンドFIFOがピクセルデータで最初に満たされるまで12Tサイクルの遅れが生じます。

4.  FIFOへのプッシュ。このステップでは、以前にフェッチされたピクセルデータが実際のピクセルにデコードされ（前述のすべての属性を含む）、フェッチャーが現在バックグラウンド/ウィンドウまたはスプライトピクセルのいずれをフェッチしているかに応じて、対応するFIFOにロードされます。

 注意: 背景ピクセルをフェッチしている間、このステップは背景 FIFO が完全に空の場合にのみ実行されます。空でない場合、このステップは成功するまで毎サイクル繰り返されます。ここまでのステップは通常6Tサイクルしかかからず、PPUは8Tサイクルで全8ピクセルをシフトアウトするので、このステップは通常成功するまでに2回再起動する必要がある。

### LCDへのピクセルのプッシュ

各サイクルにおいて、Pixel Fetcherをクロックで駆動した後、PPUはLCDにピクセルをプッシュしようとしますが、これはバックグラウンドFIFOにピクセルがある場合にのみ実行されます。スプライトFIFOにピクセルがあれば、スプライトピクセルはシフトアウトされ、背景ピクセルと "マージ "される。この処理の詳細は後ほど説明します。マージされたピクセルは、現在の走査線と現在のX位置で表示される。PPUは、ピクセルがシフトアウトされた後にインクリメントされるトラックを保持している。背景FIFOが空の場合、ここでは何も起こらない。

![fifo_basic](https://github.com/asaioe99/Gameboy/blob/main/img/fifo_basic.png)

### サブタイルレイヤーでの SCX

SCX レジスタを使用すると、タイル単位ではなくピクセル単位で背景をスクロールすることができます。水平スクロールのタイル単位の部分はフェッチプロセスで処理されますが、残りのスクロールは実際にはスキャンラインの開始時に背景FIFOからピクセルをシフトしながら行われます。SCX mod 8ピクセルは、LCDにプッシュされるのではなく、各スキャンラインの開始時に破棄される。これは、PPUモード3がSCX mod 8サイクルによって拡張される原因ともなっている。

![fifo_scx_per_pixel](https://github.com/asaioe99/Gameboy/blob/main/img/fifo_scx_per_pixel.png)

### スプライトフェッチ

スプライトバッファ内のいずれかのスプライトのX-Positionが、現在のPixel-X-Position + 8以下の場合、スプライトフェッチが開始されます。これにより、Background Fetcherはステップ1にリセットされ、一時的に停止します。LCDにピクセルをプッシュするピクセルシフターも一時停止します。スプライトフェッチャーの動作は、バックグラウンドフェッチャーと非常に似ています。

1. タイル番号の取得：Background Fetcherの最初のステップと同じですが、タイル番号はVRAMではなく、単にスプライトバッファから読み取られます。

2. タイルデータ（低）を取得する。ただし、スプライトは常に8000-addressing-modeを使用するため、このステップはLCDCビットに影響されません。

3. タイルデータ取得（High）。Background Fetcherのステップと同じです。
4. FIFOにプッシュ。フェッチされたピクセルデータは、このステップの最初のサイクルでFIFOにロードされ、同じサイクルで最初のスプライトピクセルがレンダリングされるようにします。ただし、新しいスプライトピクセルをレンダリングすべきかどうかのチェックが最初に行われるため、たとえば、両方のスプライトのX値が8未満であったり、両方のスプライトのX値が同じであったりすると、PPUが2つのスプライトフェッチ間でピクセルをまったくシフトアウトしない可能性があります。

注：このステップでは、画面上に実際に表示されているピクセルだけがFIFOにロードされます。X値が8のスプライトは、8つのピクセルすべてがロードされ、X値が7のスプライトは、右端の7つのピクセルだけがロードされます。さらに、ピクセルがFIFOスロットにロードされるのは、与えられたスロットにすでにピクセルが存在しない場合のみです。例えば、スプライトFIFOに前に取り出したスプライトのピクセルが1つだけある場合、現在取り出したスプライトの最初のピクセルは捨てられ、最後の7つのピクセルだけがFIFOにロードされ、最初のスプライトのピクセルは保持されます。


### タイミングの問題

スプライトフェッチが開始されると、Background Fetcherはステップ1にリセットされて一時停止し、スプライトデータがフェッチされてスプライトFIFOにロードされた後、バックグラウンドピクセル取得を再開することができるようになります。このため、スプライトフェッチが開始される前にBackground FIFOにキューイングされているピクセル数によって、PPUの動作が異なることになります。

スプライトフェッチが終了し、Background Fetcherが再起動すると、PPUは即座にLCDへのピクセルプッシュを開始する。ただし、8個の背景ピクセルをフェッチするには6Tサイクルが必要で、これは6ピクセルがシフトアウトされるのと同じ時間だ。スプライトのフェッチが終わったときに、バックグラウンドFIFOの残りが6ピクセル以下であれば、PPUはバックグラウンドフェッチャーが新しいピクセルをフェッチするのを待つ必要があり、その間はアイドル状態となる。ここで適用される遅延は、6 - REMAINING_PIXEL_COUNTに等しく、REMAINING_PIXEL_COUNTはスプライトフェッチが終了したときのBackground FIFOのピクセル数である。

下図は、X=68（LCD位置60）にあるスプライトをフェッチする場合のタイミング例です。60 mod 8 = 4なので、スプライトフェッチ開始前にBackground FIFOには4ピクセルが格納されています。

![fifo_sprite_fetch_timing](https://github.com/asaioe99/Gameboy/blob/main/img/fifo_sprite_fetch_timing.png)

### ピクセルミキシング

シフト中にBackgroundとSpriteのFIFOに1画素でも入っていれば、両者をシフトアウトして以下のように比較します。

    1) スプライトピクセルの色番号が0の場合、BackgroundピクセルはLCDに押し出されます。
    2) BG-to-OBJ-Priorityビットが1で、Background Pixelの色番号が0以外の場合、Background PixelはLCDに押されます。
    3) 上記のいずれの条件にも当てはまらない場合、スプライトピクセルはLCDにプッシュされます。

### ウィンドウのフェッチ

各ピクセルがシフトアウトされた後、PPUはそれがウィンドウに到達したかどうかをチェックする。これは、以下の条件をチェックすることによって行われます。

```
LCDCレジスタのビット5が1に設定されている。
条件WY=LYが、現在のレンダリングフレームのいずれかの時点で真であった。
シフターの現在のX位置がWX - 7以上である。
```
の条件がすべて当てはまる場合、ウィンドウ・フェッチが開始される。バックグラウンドフェッチャーの状態はステップ1に完全にリセットされ、フェッチャーの内部X-Position-Counterは0にリセットされ、バックグラウンドFIFOがクリアされる。バックグラウンド・フェッチャは通常通り動作を続けますが、ウィンドウ関連のLCDCビットを考慮するようになり、SCXとSCYの値は完全に無視されます。フェッチ処理のすべての変更の詳細については、上記の「バックグラウンド画素フェッチ」セクションで説明されています。

### スキャンラインの終了

内部X-Position-Counterが160に達するとすぐに(160番目のピクセルがちょうど押されたことを意味する)、PPUはHBlankモードに入り、すべてのフェッチャーおよびFIFO動作が停止される。レジスタは次のスキャンラインに備えてリセットされる。
タイミング図

次の図は、PPUモード3におけるいくつかの基本的なケースのタイミングを示している(もちろん、ノンスケール)。

![fifo_timing](https://github.com/asaioe99/Gameboy/blob/main/img/fifo_timing.png)

## PPUレジスタ
### LCDコントロールレジスタ (LCDC : $FF40)

LCDCレジスタは、LCDにとって最も重要な制御レジスタの1つです。このレジスタの8ビットはそれぞれフラグであり、どの要素を表示するかなどを決定します。以下は、各ビットの機能についての概要です。

```
ビット7 LCDディスプレイイネーブル
        このビットを0に設定すると、PPUが完全に無効になります。画面はオフになります。
ビット6 Windowタイルマップセレクト
        1に設定すると、Windowは$9C00-$9FFFに位置する背景マップを使用します。それ以外の場合は、$9800-$9BFFを使用します。
ビット5 Window Display Enable
        このビットを0に設定すると、ウィンドウ層が完全に非表示になります。
Bit 4 タイルデータ選択
        1に設定すると、タイルデータのフェッチに8000方式が使用されます。それ以外の場合は、8800方式を使用します。
ビット3 BG Tile Map Select
        1に設定すると、Backgroundは$9C00-$9FFFに位置する背景マップを使用します。そうでない場合は、$9800-$9BFFを使用します。
ビット2 スプライトサイズ
        1に設定すると、スプライトは1x2 Tile (8x16 pixel)のオブジェクトとして表示されます。そうでない場合は、1x1 Tileで表示されます。
Bit 1 スプライトイネーブル
        このビットが1に設定されている場合のみ、スプライトは画面に描画されます。
Bit 0 BG/Window Enable（ウィンドウ有効
        このビットが0に設定されている場合、BackgroundとWindowタイルは描画されません。スプライトは影響を受けません。
```
### LCDC.7 - LCDディスプレイイネーブル

このビットはPPUが全くアクティブであるか否かを制御する。PPUはこのビットが1に設定されている間のみ動作する。0に設定されるとすぐに画面は真っ白になり、PPUはすべての動作を停止する。また、PPUは「リセット」を行うが、これについては後述する。

### LCDC.6 - ウィンドウタイルマップ選択
このビットは、ウィンドウ層に表示されるタイルのタイル番号を決定するために、どの背景マップを使用するかを制御する。1に設定すると、$9C00-$9FFFにある背景マップが使用され、そうでなければ、$9800-$9BFFにあるものが使用されます。

### LCDC.5 - ウィンドウ表示イネーブル
このビットは、Windowレイヤーを全くレンダリングしないかどうかを制御します。0に設定すると、レンダリングされないので、Window関連のすべてを無視することができます。それ以外の場合、Windowは通常通りレンダリングされる。

### LCDC.4 - タイルデータ選択
このビットは、タイルデータのフェッチに使用するアドレスモードを決定する。1に設定すると、8000方式が使用されます。そうでなければ、8800方式が使用されます。(これらの方法は、上記のタイルデータのセクションで説明されています。）

### LCDC.3 - BG タイルマップ選択
このビットは、Backgroundレイヤーに表示されるタイルのタイル番号を決定するために、どのBackground Mapを使用するかを制御する。1に設定されている場合、$9C00-$9FFFにある背景マップが使用され、そうでなければ、$9800-$9BFFにあるものを使用します。

### LCDC.2 - スプライトのサイズ
上記のスプライトの説明で述べたように、"Tall Sprite Mode "を有効にできるオプションがある。このビットを1に設定すると、そのようになります。このモードでは、各スプライトは1つではなく、2つのタイルを重ねたもので構成されています。これらのタイル番号は、次のように計算されます。

一番上のタイルのタイル番号は、OAMエントリのタイル番号を使用し、最下位ビットを0に設定する。 一番下のタイルのタイル番号は、最下位ビットを1に設定することによって計算される。

例 スプライトサイズビットが1に設定され、1x2タイルのスプライトが有効になる。PPUは、タイル番号0x81のスプライトのOAMエントリーを処理する。この場合、トップタイルの最下位ビットを0に設定し、タイル番号0x80となる。下のタイルの最下位ビットは1にセットされ、タイル番号0x81となる。OAMエントリのタイル番号が0x80の場合も、最下位ビットだけが異なるため、全く同じタイル番号が使用される。

### LCDC.1 - スプライトイネーブル
このビットは、スプライトが全くレンダリングされないかどうかを制御する。このビットを0に設定すると、すべてのスプライトが非表示になり、そうでなければ、通常通りレンダリングされます。

### LCDC.0 - BG/Window イネーブル
このビットはBackgroundとWindowタイルが描画されるかどうかを制御します。0に設定された場合、BackgroundとWindowタイルは描画されず、すべてのピクセルが白（色0）として描画されます。スプライトは影響を受けないので、唯一の例外である。

注：このビットは、ゲームボーイ・カラーでは機能が異なります。

## LCD状態レジスタ(STAT : $FF41)
STATレジスタはCPUがPPUの状態を決定するための情報ビットと、PPUの割り込みトリガー動作に影響するビットの両方を含みます。以下は各ビットの機能に対する概要です。

```
ビット7 未使用（常に1）
ビット6 LYC=LY STAT割り込みイネーブル
         このビットを1にすることで、「LYC=LY条件」によるSTAT割り込みの発生が可能になります。
ビット5 モード2 STAT 割り込みイネーブル
         このビットを1に設定することで、"モード2条件 "によるSTAT割り込みのトリガを有効にします。
ビット4 モード1 STAT 割り込みイネーブル
         このビットを1に設定すると、STAT 割り込み信号のトリガとなるモード 1 状態を有効にします。
Bit 3 モード0 STAT 割り込みイネーブル
         このビットを1に設定すると、モード0条件がSTAT割り込みのトリガとして有効になります。
Bit 2 同時発生フラグ
         このビットはLYレジスタの値がLYCレジスタの値と等しい場合にPPUによって設定されます。
ビット 1-0 PPU モード
         PPUがどのモードにあるかによってこの2ビットが設定される．
          * 0 : H-ブランク
          * 1 : V-ブランク
          * 2 : OAMスキャン
          * 3 : 描画
```

### STAT.6 - LYC=LY STAT割り込みイネーブル
このビット（ビット5～3と同様）は、STAT割り込みを発生させるための「コンディション・イネーブラー」として機能します。このビットは、LYレジスタ（現在の走査線数）とLYCレジスタ（$FF45、後で説明）の比較によってSTAT割り込みをトリガさせることができま す。もし値が等しければ、STAT割り込みがトリガされます。

注：この割り込みは、後で説明するSTAT IRQブロッキングにより、各走査線につき一度だけトリガされます。

### STAT.5-3 - PPUモードSTATインタラプトイネーブル
ビット6と同様に、ビット5～3はSTAT割り込みの "コンディション・イネーブル "として動作します。具体的には、以下の表で説明するように、PPUが特定のモードに入るたびにSTAT割り込みをトリガさせることができます。

|Bit |PPU Mode|
|---|---|
|STAT.5 |	Mode 2 (OAM Scan)|
|STAT.4 |	Mode 1 (VBlank)|
|STAT.3 |	Mode 0 (HBlank)|

### STAT.2 - 同時発生フラグ
このビットは新しい走査線が開始されるか、またはLYCレジスタの内容が変更されるたびにPPUによって更新される。LY=LYCの場合、このビットは1にセットされ、それ以外の場合は0にセットされます。リードオンリーなので、CPUによる上書きはできません。

### STAT.1-0 - PPUモード
STATレジスタの下位2ビットはCPUに対してリードオンリーであり、PPUがモードを切り替えるたびに更新される。(Ref. PPU Mode Timing) これはいくつかのゲームにとって重要で、PPUがどのモードにあるかを割り込みで判断するのではなく、これらのビットの値を継続的にチェックするからです。

### STAT IRQsとブロッキング

STAT割り込みは、STATレジスタのビット6～3の状態に基づいて、条件付きでトリガされます。選択された条件のいずれかが満たされると、割り込みフラグレジスタ（IF）のビット1が設定されます。しかし、選択された条件の少なくとも1つが満たされている限り、それ以上STAT割り込みを発生させることはできません。これは「STAT IRQブロッキング」と呼ばれます。

例 LYCレジスタが値0x10に設定され、LY=LYC STAT割り込み条件が有効になっています。LY=0x10になるとすぐにSTAT割り込みが発生します。PPUが同じ走査線上にある間、モード0 STATインタラプト条件がイネーブルになる。通常、PPUがモード0に切り替わると同時に、スキャンライン終端に向かって再びSTAT割り込みが発生しますが、LY=LYC条件を満たしたままなので、「条件を満たしていない」から「条件を満たしている」に遷移せず、割り込みを発生させません。次のスキャンラインでは、LY=LYCの条件は満たされなくなるので、PPUがモード0に切り替わると同時にそこで割り込みが発生します。
